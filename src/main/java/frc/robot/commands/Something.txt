package frc.robot.commands;

import com.pathplanner.lib.path.PathPlannerPath;

import edu.wpi.first.wpilibj2.command.CommandBase;
import frc.robot.commands.TrajectoryCreation;
import frc.robot.subsystems.Climb;
import frc.robot.subsystems.PoseEstimator;
import frc.robot.subsystems.Vision;
public class AutoClimb extends CommandBase {

    private final DriveTrain m_drive;
    private final Vision m_vision;
    private final Climb m_climb;
    
    private static final double CHAIN_OFFSET = 12.0;

    public AutoClimb(DriveTrain drive, Vision vision, Climb climb) {
        m_drive = drive;
        m_vision = vision;
        m_climb = climb;
        
        addRequirements(drive, vision, climb);
    }

    @Override 
    public void initialize() {

        // Reset modules to known state
        m_drive.resetAlignment();
        
        // Reset odometry
        m_drive.resetOdometry(startPose);

        // Reset vision
        m_vision.resetRobotPose();

        // Align to closest tag 
        alignToTag();
    }

    public void alignToTag() {
        
        if (m_vision.hasBestTarget()) {
            double offset = m_vision.returnYaw();

            // Rotate in place
            m_drive.drive(0, offset, false);
        }
    }

    @Override
    public void execute() {
        
        // Get current robot field pose
        Pose2d pose = m_drive.getPose();  

        // Calculate next pose with chain offset
        Pose2d nextPose = new Pose2d(pose.getX() + CHAIN_OFFSET, 
                                     pose.getY(),
                                     pose.getRotation());

        // Convert to chassis speeds
        ChassisSpeeds speeds = m_drive.poseToChassisSpeeds(nextPose);
        
        // Drive to chain position
        m_drive.setChassisSpeeds(speeds);
        
        // Extend climb mechanism
        m_climb.extendToChain();

    }

    @Override
    public void end(boolean interrupted) {
        m_drive.drive(0, 0, false);
        m_climb.retractClimber();
    }

    @Override
    public boolean isFinished() {
        return m_climb.isLatched(); 
    }

}